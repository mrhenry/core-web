{"version":3,"file":"index.af98d0b733e109fd3094.2021.js","mappings":"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","sources":["webpack:///../../core-web/modules/IntersectionObserver.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///./js/index.js"],"sourcesContent":["(function(undefined) {\nif (!(\"IntersectionObserver\"in window&&\"IntersectionObserverEntry\"in window&&\"intersectionRatio\"in window.IntersectionObserverEntry.prototype\n)) {\n// IntersectionObserver\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n\n(function(window, document) {\n'use strict';\n\nvar supportedNatively = 'IntersectionObserver' in window &&\n'IntersectionObserverEntry' in window &&\n'intersectionRatio' in window.IntersectionObserverEntry.prototype;\n\t\nif (supportedNatively) {\n\treturn;\n}\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observing a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n\tthis.time = entry.time;\n\tthis.target = entry.target;\n\tthis.rootBounds = entry.rootBounds;\n\tthis.boundingClientRect = entry.boundingClientRect;\n\tthis.intersectionRect = entry.intersectionRect || getEmptyRect();\n\ttry {\n\t\tthis.isIntersecting = !!entry.intersectionRect;\n\t} catch (err) {\n\t\t// This means we are using the IntersectionObserverEntry polyfill which has only defined a getter\n\t}\n\n\t// Calculates the intersection ratio.\n\tvar targetRect = this.boundingClientRect;\n\tvar targetArea = targetRect.width * targetRect.height;\n\tvar intersectionRect = this.intersectionRect;\n\tvar intersectionArea = intersectionRect.width * intersectionRect.height;\n\n\t// Sets intersection ratio.\n\tif (targetArea) {\n\t\t// Round the intersection ratio to avoid floating point math issues:\n\t\t// https://github.com/w3c/IntersectionObserver/issues/324\n\t\tthis.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n\t} else {\n\t\t// If area is zero and is intersecting, sets to 1, otherwise to 0\n\t\tthis.intersectionRatio = this.isIntersecting ? 1 : 0;\n\t}\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n\tvar options = opt_options || {};\n\n\tif (typeof callback != 'function') {\n\t\tthrow new Error('callback must be a function');\n\t}\n\n\tif (options.root && options.root.nodeType != 1) {\n\t\tthrow new Error('root must be an Element');\n\t}\n\n\t// Binds and throttles `this._checkForIntersections`.\n\tthis._checkForIntersections = throttle(\n\t\t\tthis._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n\t// Private properties.\n\tthis._callback = callback;\n\tthis._observationTargets = [];\n\tthis._queuedEntries = [];\n\tthis._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n\t// Public properties.\n\tthis.thresholds = this._initThresholds(options.threshold);\n\tthis.root = options.root || null;\n\tthis.rootMargin = this._rootMarginValues.map(function(margin) {\n\t\treturn margin.value + margin.unit;\n\t}).join(' ');\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n\tvar isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n\t\treturn item.element == target;\n\t});\n\n\tif (isTargetAlreadyObserved) {\n\t\treturn;\n\t}\n\n\tif (!(target && target.nodeType == 1)) {\n\t\tthrow new Error('target must be an Element');\n\t}\n\n\tthis._registerInstance();\n\tthis._observationTargets.push({element: target, entry: null});\n\tthis._monitorIntersections();\n\tthis._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n\tthis._observationTargets =\n\t\t\tthis._observationTargets.filter(function(item) {\n\n\t\treturn item.element != target;\n\t});\n\tif (!this._observationTargets.length) {\n\t\tthis._unmonitorIntersections();\n\t\tthis._unregisterInstance();\n\t}\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n\tthis._observationTargets = [];\n\tthis._unmonitorIntersections();\n\tthis._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n\tvar records = this._queuedEntries.slice();\n\tthis._queuedEntries = [];\n\treturn records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n\tvar threshold = opt_threshold || [0];\n\tif (!Array.isArray(threshold)) threshold = [threshold];\n\n\treturn threshold.sort().filter(function(t, i, a) {\n\t\tif (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n\t\t\tthrow new Error('threshold must be a number between 0 and 1 inclusively');\n\t\t}\n\t\treturn t !== a[i - 1];\n\t});\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n\tvar marginString = opt_rootMargin || '0px';\n\tvar margins = marginString.split(/\\s+/).map(function(margin) {\n\t\tvar parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\t\tif (!parts) {\n\t\t\tthrow new Error('rootMargin must be specified in pixels or percent');\n\t\t}\n\t\treturn {value: parseFloat(parts[1]), unit: parts[2]};\n\t});\n\n\t// Handles shorthand.\n\tmargins[1] = margins[1] || margins[0];\n\tmargins[2] = margins[2] || margins[0];\n\tmargins[3] = margins[3] || margins[1];\n\n\treturn margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibility state is visible.\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function() {\n\tif (!this._monitoringIntersections) {\n\t\tthis._monitoringIntersections = true;\n\n\t\t// If a poll interval is set, use polling instead of listening to\n\t\t// resize and scroll events or DOM mutations.\n\t\tif (this.POLL_INTERVAL) {\n\t\t\tthis._monitoringInterval = setInterval(\n\t\t\t\t\tthis._checkForIntersections, this.POLL_INTERVAL);\n\t\t}\n\t\telse {\n\t\t\taddEvent(window, 'resize', this._checkForIntersections, true);\n\t\t\taddEvent(document, 'scroll', this._checkForIntersections, true);\n\n\t\t\tif (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n\t\t\t\tthis._domObserver = new MutationObserver(this._checkForIntersections);\n\t\t\t\tthis._domObserver.observe(document, {\n\t\t\t\t\tattributes: true,\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tcharacterData: true,\n\t\t\t\t\tsubtree: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function() {\n\tif (this._monitoringIntersections) {\n\t\tthis._monitoringIntersections = false;\n\n\t\tclearInterval(this._monitoringInterval);\n\t\tthis._monitoringInterval = null;\n\n\t\tremoveEvent(window, 'resize', this._checkForIntersections, true);\n\t\tremoveEvent(document, 'scroll', this._checkForIntersections, true);\n\n\t\tif (this._domObserver) {\n\t\t\tthis._domObserver.disconnect();\n\t\t\tthis._domObserver = null;\n\t\t}\n\t}\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n\tvar rootIsInDom = this._rootIsInDom();\n\tvar rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n\tthis._observationTargets.forEach(function(item) {\n\t\tvar target = item.element;\n\t\tvar targetRect = getBoundingClientRect(target);\n\t\tvar rootContainsTarget = this._rootContainsTarget(target);\n\t\tvar oldEntry = item.entry;\n\t\tvar intersectionRect = rootIsInDom && rootContainsTarget &&\n\t\t\t\tthis._computeTargetAndRootIntersection(target, rootRect);\n\n\t\tvar newEntry = item.entry = new IntersectionObserverEntry({\n\t\t\ttime: now(),\n\t\t\ttarget: target,\n\t\t\tboundingClientRect: targetRect,\n\t\t\trootBounds: rootRect,\n\t\t\tintersectionRect: intersectionRect\n\t\t});\n\n\t\tif (!oldEntry) {\n\t\t\tthis._queuedEntries.push(newEntry);\n\t\t} else if (rootIsInDom && rootContainsTarget) {\n\t\t\t// If the new entry intersection ratio has crossed any of the\n\t\t\t// thresholds, add a new entry.\n\t\t\tif (this._hasCrossedThreshold(oldEntry, newEntry)) {\n\t\t\t\tthis._queuedEntries.push(newEntry);\n\t\t\t}\n\t\t} else {\n\t\t\t// If the root is not in the DOM or target is not contained within\n\t\t\t// root but the previous entry for this target had an intersection,\n\t\t\t// add a new record indicating removal.\n\t\t\tif (oldEntry && oldEntry.isIntersecting) {\n\t\t\t\tthis._queuedEntries.push(newEntry);\n\t\t\t}\n\t\t}\n\t}, this);\n\n\tif (this._queuedEntries.length) {\n\t\tthis._callback(this.takeRecords(), this);\n\t}\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n\t\tfunction(target, rootRect) {\n\n\t// If the element isn't displayed, an intersection can't happen.\n\tif (window.getComputedStyle(target).display == 'none') return;\n\n\tvar targetRect = getBoundingClientRect(target);\n\tvar intersectionRect = targetRect;\n\tvar parent = getParentNode(target);\n\tvar atRoot = false;\n\n\twhile (!atRoot) {\n\t\tvar parentRect = null;\n\t\tvar parentComputedStyle = parent.nodeType == 1 ?\n\t\t\t\twindow.getComputedStyle(parent) : {};\n\n\t\t// If the parent isn't displayed, an intersection can't happen.\n\t\tif (parentComputedStyle.display == 'none') return;\n\n\t\tif (parent == this.root || parent == document) {\n\t\t\tatRoot = true;\n\t\t\tparentRect = rootRect;\n\t\t} else {\n\t\t\t// If the element has a non-visible overflow, and it's not the <body>\n\t\t\t// or <html> element, update the intersection rect.\n\t\t\t// Note: <body> and <html> cannot be clipped to a rect that's not also\n\t\t\t// the document rect, so no need to compute a new intersection.\n\t\t\tif (parent != document.body &&\n\t\t\t\t\tparent != document.documentElement &&\n\t\t\t\t\tparentComputedStyle.overflow != 'visible') {\n\t\t\t\tparentRect = getBoundingClientRect(parent);\n\t\t\t}\n\t\t}\n\n\t\t// If either of the above conditionals set a new parentRect,\n\t\t// calculate new intersection data.\n\t\tif (parentRect) {\n\t\t\tintersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n\t\t\tif (!intersectionRect) break;\n\t\t}\n\t\tparent = getParentNode(parent);\n\t}\n\treturn intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n\tvar rootRect;\n\tif (this.root) {\n\t\trootRect = getBoundingClientRect(this.root);\n\t} else {\n\t\t// Use <html>/<body> instead of window since scroll bars affect size.\n\t\tvar html = document.documentElement;\n\t\tvar body = document.body;\n\t\trootRect = {\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\tright: html.clientWidth || body.clientWidth,\n\t\t\twidth: html.clientWidth || body.clientWidth,\n\t\t\tbottom: html.clientHeight || body.clientHeight,\n\t\t\theight: html.clientHeight || body.clientHeight\n\t\t};\n\t}\n\treturn this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {Object} rect The rect object to expand.\n * @return {Object} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n\tvar margins = this._rootMarginValues.map(function(margin, i) {\n\t\treturn margin.unit == 'px' ? margin.value :\n\t\t\t\tmargin.value * (i % 2 ? rect.width : rect.height) / 100;\n\t});\n\tvar newRect = {\n\t\ttop: rect.top - margins[0],\n\t\tright: rect.right + margins[1],\n\t\tbottom: rect.bottom + margins[2],\n\t\tleft: rect.left - margins[3]\n\t};\n\tnewRect.width = newRect.right - newRect.left;\n\tnewRect.height = newRect.bottom - newRect.top;\n\n\treturn newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n\t\tfunction(oldEntry, newEntry) {\n\n\t// To make comparing easier, an entry that has a ratio of 0\n\t// but does not actually intersect is given a value of -1\n\tvar oldRatio = oldEntry && oldEntry.isIntersecting ?\n\t\t\toldEntry.intersectionRatio || 0 : -1;\n\tvar newRatio = newEntry.isIntersecting ?\n\t\t\tnewEntry.intersectionRatio || 0 : -1;\n\n\t// Ignore unchanged ratios\n\tif (oldRatio === newRatio) return;\n\n\tfor (var i = 0; i < this.thresholds.length; i++) {\n\t\tvar threshold = this.thresholds[i];\n\n\t\t// Return true if an entry matches a threshold or if the new ratio\n\t\t// and the old ratio are on the opposite sides of a threshold.\n\t\tif (threshold == oldRatio || threshold == newRatio ||\n\t\t\t\tthreshold < oldRatio !== threshold < newRatio) {\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n\treturn !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n\treturn containsDeep(this.root || document, target);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n\tif (registry.indexOf(this) < 0) {\n\t\tregistry.push(this);\n\t}\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n\tvar index = registry.indexOf(this);\n\tif (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n\treturn window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n\tvar timer = null;\n\treturn function () {\n\t\tif (!timer) {\n\t\t\ttimer = setTimeout(function() {\n\t\t\t\tfn();\n\t\t\t\ttimer = null;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n\tif (typeof node.addEventListener == 'function') {\n\t\tnode.addEventListener(event, fn, opt_useCapture || false);\n\t}\n\telse if (typeof node.attachEvent == 'function') {\n\t\tnode.attachEvent('on' + event, fn);\n\t}\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n\tif (typeof node.removeEventListener == 'function') {\n\t\tnode.removeEventListener(event, fn, opt_useCapture || false);\n\t}\n\telse if (typeof node.detatchEvent == 'function') {\n\t\tnode.detatchEvent('on' + event, fn);\n\t}\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object} The intersection rect or undefined if no intersection\n *     is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n\tvar top = Math.max(rect1.top, rect2.top);\n\tvar bottom = Math.min(rect1.bottom, rect2.bottom);\n\tvar left = Math.max(rect1.left, rect2.left);\n\tvar right = Math.min(rect1.right, rect2.right);\n\tvar width = right - left;\n\tvar height = bottom - top;\n\n\treturn (width >= 0 && height >= 0) && {\n\t\ttop: top,\n\t\tbottom: bottom,\n\t\tleft: left,\n\t\tright: right,\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {Object} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n\tvar rect;\n\n\ttry {\n\t\trect = el.getBoundingClientRect();\n\t} catch (err) {\n\t\t// Ignore Windows 7 IE11 \"Unspecified error\"\n\t\t// https://github.com/w3c/IntersectionObserver/pull/205\n\t}\n\n\tif (!rect) return getEmptyRect();\n\n\t// Older IE\n\tif (!(rect.width && rect.height)) {\n\t\trect = {\n\t\t\ttop: rect.top,\n\t\t\tright: rect.right,\n\t\t\tbottom: rect.bottom,\n\t\t\tleft: rect.left,\n\t\t\twidth: rect.right - rect.left,\n\t\t\theight: rect.bottom - rect.top\n\t\t};\n\t}\n\treturn rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {Object} The empty rect.\n */\nfunction getEmptyRect() {\n\treturn {\n\t\ttop: 0,\n\t\tbottom: 0,\n\t\tleft: 0,\n\t\tright: 0,\n\t\twidth: 0,\n\t\theight: 0\n\t};\n}\n\n/**\n * Checks to see if a parent element contains a child element (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n\tvar node = child;\n\twhile (node) {\n\t\tif (node == parent) return true;\n\n\t\tnode = getParentNode(node);\n\t}\n\treturn false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n\tvar parent = node.parentNode;\n\n\tif (parent && parent.nodeType == 11 && parent.host) {\n\t\t// If the parent is a shadow root, return the host element.\n\t\treturn parent.host;\n\t}\n\n\tif (parent && parent.assignedSlot) {\n\t\t// If the parent is distributed in a <slot>, return the parent of a slot.\n\t\treturn parent.assignedSlot.parentNode;\n\t}\n\n\treturn parent;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}(window, document));\n}}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const milestoneObserver = new IntersectionObserver((entries) => {\n\tif (!entries || entries.length < 1) {\n\t\t\treturn;\n\t}\n\n\tentries.forEach(entry => {\n\t\tif (\n\t\t\tentry.intersectionRatio > 0.6 &&\n\t\t\tentry.target &&\n\t\t\t!entry.target.hasAttribute('milestone-visible')\n\t\t) {\n\t\t\tentry.target.setAttribute('milestone-visible', 'true');\n\t\t} else {\n\t\t\t\tentry.target.removeAttribute('milestone-visible');\n\t\t}\n\t});\n}, {\n\tthreshold: 0.6\n});\n\nfunction init() {\n\tconst milestones = document.querySelectorAll('[milestone-observer]');\n\tif (!milestones || milestones.length < 1) {\n\t\t\treturn;\n\t}\n\n\tmilestones.forEach((el) => {\n\t\t\tmilestoneObserver.observe(el);\n\t});\n};\n\ninit();\nrequestAnimationFrame(init);\nwindow.addEventListener('load', init);\n\nwindow.addEventListener('load', () => {\n\tdocument.documentElement.setAttribute('loaded', '');\n})\n"],"names":["undefined","window","IntersectionObserverEntry","prototype","document","registry","IntersectionObserver","THROTTLE_TIMEOUT","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","target","this","_observationTargets","some","item","element","nodeType","Error","_registerInstance","push","entry","_monitorIntersections","_checkForIntersections","unobserve","filter","length","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","_queuedEntries","slice","_initThresholds","opt_threshold","threshold","Array","isArray","sort","t","i","a","isNaN","_parseRootMargin","opt_rootMargin","margins","split","map","margin","parts","exec","value","parseFloat","unit","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","top","bottom","left","right","width","height","forEach","targetRect","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","intersectionRect","_computeTargetAndRootIntersection","newEntry","time","performance","now","boundingClientRect","rootBounds","_hasCrossedThreshold","isIntersecting","_callback","getComputedStyle","display","rect1","rect2","parent","getParentNode","atRoot","parentRect","parentComputedStyle","root","body","documentElement","overflow","Math","max","min","html","clientWidth","clientHeight","_expandRectByRootMargin","rect","_rootMarginValues","newRect","oldRatio","intersectionRatio","newRatio","thresholds","containsDeep","indexOf","index","splice","err","targetArea","intersectionArea","Number","toFixed","callback","opt_options","fn","timeout","timer","options","bind","setTimeout","rootMargin","join","node","event","opt_useCapture","addEventListener","attachEvent","removeEventListener","detatchEvent","el","child","parentNode","host","assignedSlot","call","self","global","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","obj","prop","hasOwnProperty","milestoneObserver","entries","hasAttribute","setAttribute","removeAttribute","init","milestones","querySelectorAll","requestAnimationFrame"],"sourceRoot":""}